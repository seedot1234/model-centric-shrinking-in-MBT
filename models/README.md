# AMP Models

These are the Axini Modeling Language (AMP) models that were used in the experiments. They are:

- **smartdoor**:
  SmartDoor is an IoT door that locks, unlocks, opens, and closes using an app. Locking the door is done with a four-digit passcode, and unlocking it requires that same user-defined passcode. An `?invalid_passcode` would be any passcode that isn't a positive 4-digit number. Whenever the app sends a message (`?open`, `?close`, `?lock`, `?unlock`), the door sends a response back (such as `!opened` or `!closed`). Commands are only accepted when they are possible and are otherwise met with the `!invalid_command` response. For instance, the door cannot `?unlock` if it is `!open`, and it cannot `?close` if it is already `!locked`. If an `?incorrect_passcode` has been entered three times in a row without entering a `?correct_passcode`, SmartDoor shuts off (i.e. `!shut_off`). In this shut-off state, the door can receive up to one command from the app. Afterwards, the app is no longer able to send messages to the door.

  Because our shrinking algorithm works with Labeled Transition Systems (LTSs) and therefore doesn't have access to variables, the passcode cannot be passed along with the `?lock` and `?unlock` stimuli as a parameter. We therefore introduce different `?lock` and `?unlock` variants: `?lock_correct_passcode`, `?lock_invalid_passcode`, `?unlock_correct_passcode`, `?unlock_incorrect_passcode`, and `?unlock_invalid_passcode`. The different passcode attempts are encoded in the states. This means that there are three variants of the locked state: `locked` (no incorrect attempts), `locked_1` (one incorrect attempt), and `locked_2` (two incorrect attempts; will `!shut_off` if another incorrect passcode is entered).

- **koopman**:
  Koopman *et al.*[^1] describe a vending machine SUT that accepts two types of coins (`?Coin1` and `?Coin2`) and keeps track of the balance inserted thus far. The user can choose between five different products (e.g. `Coffee`, `Espresso`, `French`, `Wiener`, `Double`) by pressing the `?Choice`-button. If there is enough balance, the machine will dispense the chosen product after pressing the `?Go`-button. All products cost 3, except for coffee which costs 2. The `?Info`-button can be pressed to get the current balance and chosen product, and the `?Reset`-button can be used in order to reset the choice to `None` and the balance to zero. If there was any remaining balance after a reset, this will be returned to the user in the form of change (with responses like `!Change_2` and `!Change_7`). The same vending machine was also used by Meijer to validate his results.

  We translated the machine specification to an LTS by making the different states encode the chosen product and the current balance (e.g. with states such as `None_4`, `Coffee_11`, and `Espresso_0`). A maximum balance of 15 was also added to the machine in order to have a finite number of states. Users can insert a coin from any state, as long as it does not result in an exceeded maximum balance. Users can also always press the `?Choice_[product]`-button (e.g. `?Choice_Wiener` or `?Choice_Double`), which will set the chosen product. Users can also at any time press the `?Go`-button, which does nothing when there is insufficient balance or no chosen product, and will otherwise dispense the chosen product and subtract its price from the balance.

- **ATM**:
  The final experiment involves an Automatic Teller Machine (ATM). Users can interact with the ATM to `?withdraw` from and `?deposit` money to their bank card. The ATM has different bills that it can give out (i.e. `!5`, `!10`, `!20`, `!50`, and `!100`). Users start by inserting their bank card into the ATM. If it is a `!valid_card`, the user now has to enter their PIN. If the `?PIN` is `!correct`, the user gains access to their balance and can start depositing and withdrawing money, one bill at a time. After three incorrect PIN attempts, the ATM `!blocks` the bank card. Users can hold a maximum balance of 500 and a minimum balance of zero. If a user tries to withdraw money that would lead to a negative balance, the ATM returns `!insufficient_balance`. When a user successfully withdraws money, the ATM returns the value of the bill withdrawn. Upon a deposit, the ATM returns the new `!balance: <balance>`. Users can also request their current balance (i.e. `?balance`). When the user is done interacting with the ATM, they can `?exit` the system to get their `!card` back. The ATM will then sit idle until a new card is inserted. Our model of the ATM has 1969 states and 3547 transitions. It accepts 416 different stimuli and has 213 unique responses. Different implementations of the ATM were created, each with a different bug. These mutants of the system are discussed in Table~\ref{tab:ATMbugs}, whereas the AML model can be found in Appendix~\ref{ap:models:atm}.

## Files

There are three folders, each containing the models of a different experiment: smartdoor, koopman, and ATM. Per experiment, the model and the interface of the model are shown. The interface contains all the stimuli and responses that that model accepts.

[^1]: Koopman, P., Achten, P., Plasmeijer, R. (2014). Model-Based Shrinking for State-Based Testing. In: McCarthy, J. (eds) Trends in Functional Programming. TFP 2013. Lecture Notes in Computer Science, vol 8322. Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-642-45340-3_7