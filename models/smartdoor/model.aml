timeout 0.5

external 'door'

process('smartdoor') {
  include 'interface.aml'
  channel('door')
  goto 'closed'

  # In the closed state, the door can be locked and opened.
  state 'closed'
    repeat {
      o {
        receive 'close'
        send 'invalid_command'
      }
      o {
        receive 'open'
        send 'opened'
        goto 'opened'
      }
      o {
        receive 'lock_correct_passcode'
        send 'locked'
        goto 'locked'
      }
      o {
        receive 'lock_invalid_passcode'
        send 'invalid_passcode'
      }
      o {
        receive 'unlock_correct_passcode'
        send 'invalid_command'
      }
      o {
        receive 'unlock_incorrect_passcode'
        send 'invalid_command'
      }
    }

  # In the opened state, the door can be closed.
  state 'opened'
    repeat {
      o {
        receive 'close'
        send 'closed'
        goto 'closed'
      }
      o {
        receive 'open'
        send 'invalid_command'
      }
      o {
        receive 'lock_correct_passcode'
        send 'invalid_command'
      }
      o {
        receive 'unlock_correct_passcode'
        send 'invalid_command'
      }
      o {
        receive 'unlock_incorrect_passcode'
        send 'invalid_command'
      }
    }

  # In the locked state, the door can be unlocked with the right passcode.
  state 'locked'
    repeat {
      o {
        receive 'close'
        send 'invalid_command'
      }
      o {
        receive 'open'
        send 'invalid_command'
      }
      o {
        receive 'lock_correct_passcode'
        send 'invalid_command'
      }
      o {
        receive 'lock_invalid_passcode'
        send 'invalid_command'
      }
      o {
        receive 'unlock_correct_passcode'
        send 'unlocked'
        goto 'closed'
      }
      o {
        receive 'unlock_incorrect_passcode'
        send 'incorrect_passcode'
        goto 'locked_1'
      }
      o {
        receive 'unlock_invalid_passcode'
        send 'invalid_passcode'
      }
    }


  # In the locked state, the door can be unlocked with the right passcode.
  state 'locked_1'
    repeat {
      o {
        receive 'close'
        send 'invalid_command'
      }
      o {
        receive 'open'
        send 'invalid_command'
      }
      o {
        receive 'lock_correct_passcode'
        send 'invalid_command'
      }
      o {
        receive 'lock_invalid_passcode'
        send 'invalid_command'
      }
      o {
        receive 'unlock_correct_passcode'
        send 'unlocked'
        goto 'closed'
      }
      o {
        receive 'unlock_incorrect_passcode'
        send 'incorrect_passcode'
        goto 'locked_2'
      }
      o {
        receive 'unlock_invalid_passcode'
        send 'invalid_passcode'
      }
    }


# In the locked state, the door can be unlocked with the right passcode.
  state 'locked_2'
    repeat {
      o {
        receive 'close'
        send 'invalid_command'
      }
      o {
        receive 'open'
        send 'invalid_command'
      }
      o {
        receive 'lock_correct_passcode'
        send 'invalid_command'
      }
      o {
        receive 'lock_invalid_passcode'
        send 'invalid_command'
      }
      o {
        receive 'unlock_correct_passcode'
        send 'unlocked'
        goto 'closed'
      }
      o {
        receive 'unlock_incorrect_passcode'
        send 'incorrect_passcode'
        send 'shut_off'
        goto 'shut_off'
        }
      o {
        receive 'unlock_invalid_passcode'
        send 'invalid_passcode'
      }
    }


  state 'shut_off'
    choice {
      o { receive 'open' }
      o { receive 'close' }
      o { receive 'lock_correct_passcode' }
      o { receive 'lock_invalid_passcode' }
      o { receive 'unlock_correct_passcode' }
      o { receive 'unlock_incorrect_passcode'}
      o { receive 'unlock_invalid_passcode' }
    }

   choice {
     o { send 'quiescence', timeout: 1.0 }
     o {}
   }
}

